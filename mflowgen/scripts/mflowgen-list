#! /usr/bin/env mflowgen-python
#=========================================================================
# mflowgen-list
#=========================================================================
# Print list of build targets
#
# The output should look something like this:
#
#     Targets
#
#      - 0 : info
#      - 1 : freepdk-45nm
#      - 2 : constraints
#      - 3 : cadence-innovus-plugins
#      - 4 : rtl
#      - 5 : synopsys-dc-synthesis
#      - 6 : cadence-innovus-flowsetup
#      - 7 : cadence-innovus-place-route
#
# The list is generated from the dry run commands dumped by the build
# tool (e.g., make -n).
#
#  -h  --help      Display this message
#  -b  --backend   Build tool (e.g., make)
#  -s  --steps     Comma-separated list of ordered steps (e.g., "2-foo,1-bar")
#  -sg --subgraphs Comma-separated list of subgraphs (e.g., "3-gcd,4-tile")
#
# Author : Alex Carsello
# Date   : August 16, 2023
#

import argparse
import os
import re
import subprocess
import sys

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )
  p.add_argument( "-h",  "--help",      action="store_true" )
  p.add_argument( "-b",  "--backend",   default="make"      )
  p.add_argument( "-s",  "--steps",     required=True       )
  p.add_argument( "-sg", "--subgraphs", required=False      )
  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------

def main():

  opts = parse_cmdline()

  # Dump dry run commands from build tool

  if opts.backend == 'make':
    text = subprocess.check_output([ 'make', '-n' ])
  elif opts.backend == 'ninja':
    text = subprocess.check_output([ 'ninja', '-nv' ])
  else:
    assert False, 'Cannot get status from build tool ' + opts.backend

  # Convert ascii byte array to string.

  if type( text ) != str:
    text = ''.join( map( chr, text ) )
  lines = text.split('\n')

  # Identify steps that must be rebuilt (i.e., check if the dry run
  # commands show that the output stamps need to be updated)

  steps = opts.steps.split(',')
  # If subgraph arg is provided, store them
  try:
    subgraphs = opts.subgraphs.split(',')
  except AttributeError:
    subgraphs = []

  # Get subgraph lists
  subgraph_strs = {}
  for s in subgraphs:
    os.chdir( s )
    process = subprocess.Popen(['make', 'list'],
               stdout=subprocess.PIPE,
               stderr=subprocess.PIPE,
               universal_newlines=True)
    stdout, stderr = process.communicate()
    stdout_lines = stdout.split('\n')
    # Filter out lines that aren't step statuses
    target_index = stdout_lines.index("Targets:")
    stdout_lines = stdout_lines[target_index+2:]
    # Filter out trailing lines
    empty_index = stdout_lines.index("")
    stdout_lines = stdout_lines[0:empty_index]
    # Join and indent lines to show hierarchy
    list_str = '\n  '.join(stdout_lines)
    list_str = '  ' + list_str
    subgraph_strs[s] = list_str
    os.chdir( '..' )

  # Print Targets

  print()
  print( 'Targets:' )
  print()

  template_str = ' - {number:3} : {name}'
  for step in sorted(steps,
                 key=lambda x: int(x.split('-')[0]) ): # sort numerical order
    tokens = step.split('-')
    d = {
      'number'   : tokens[0],
      'name'     : '-'.join(tokens[1:]),
    }
    print( template_str.format( **d ) )
    if step in subgraphs:
      print(subgraph_strs[step])

  print()


if __name__ == '__main__':
  main()


